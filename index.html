<!DOCTYPE html>
<html>
    <head>
        <title>Markus Hustle</title>
        <script>
            //variables and constants related to grass drawing
            var controlPtCount =  10;
            var intervalY = 5;
            var width = 1;

            var colonyArr = [];
            var numColony = 30;

            const minA = 1.09;
            const maxA = 1.2;
            const minB = 1;
            const maxB = 1.8;
            const minC = -5;
            const maxC = 5;
            const minHeight = 5;
            const maxHeight = 50;
            const minWidth = 1;
            const maxWidth = 3;

            const horizontalMargin = 20;
            const verticalMargin = 20;

            const minLeaves = 4;
            const maxLeaves = 8;

            const leafDirRight = 1;
            const leafDirLeft = -1;

            var horizonRelativePos = 0.5;



            window.onload = function (){
                
                canvas = document.getElementById("canvas");
                const ctx = canvas.getContext("2d");
                canvas.width = innerWidth;
                canvas.height = innerHeight;

                    

                const windX = -1;   // wind direction vector
                const windY = 0;
                const bendabilityMin = 5;
                const bendabilityMax = 12;
                const bendability = 8; // greater than 1. The bigger this number the more the thin branches will bend first

                // the canvas height you are scaling up or down to a different sized canvas
                const windStrength = 0.01 * bendability * ((200 ** 2) / (canvas.height ** 2));  // wind strength

                const windBendRectSpeed = 0.01;  // how fast the tree reacts to the wing
                const windBranchSpring = 0.98;   // the amount and speed of the branch spring back

                const gustProbability = 1/100; // how often there is a gust of wind

                var windCycle = 0;
                var windCycleGust = 0;
                var windCycleGustTime = 0;
                var currentWind = 0;
                var windFollow = 0;
                var windActual = 0;



                ctx.moveTo(0,0);
                ctx.beginPath();

                /*
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "black";
                ctx.fill();
                */

                //mountain drawing
                var mountainCoordinates = [];
                function initializeMountain(){
                    //
                    //ctx.globalCompositeOperation = "destination-out";
                    var xInterval = 5;
                    var offsetVal = 300;
                    var mountainRelativeHeight = 0.12 * canvas.width / 2560;
                    var startingPosY = canvas.height * (horizonRelativePos - mountainRelativeHeight);
                    var startingPosX = canvas.width * ((Math.random() - 0.5) * 0.25 + 0.5);
                    var leftEnd = canvas.width * (Math.random() * 0.1 + 0.1);
                    var rightEnd = canvas.width - canvas.width * (Math.random() * 0.1 + 0.1);
                    var leftAngle = Math.atan(canvas.height * mountainRelativeHeight / (leftEnd - startingPosX));
                    var rightAngle = Math.atan(canvas.height * mountainRelativeHeight / (startingPosX - rightEnd));
                    var angle = 0;
                    
                    //mountain with a peak as starting point
                    var actualPosY = startingPosY;
                    angle = 0;
                    var divider = 1.2;
                    var degreeDiff = 30;
                    var angleDiff = Math.PI * degreeDiff / 180;
                    //left slope
                    for (var actualPosX = startingPosX; actualPosX > - xInterval; actualPosX -= xInterval) {
                        var coordinate = new Object();
                        if(actualPosY < horizonRelativePos * canvas.height) {
                            coordinate.x = actualPosX;
                            coordinate.y = actualPosY;
                        } else {
                            coordinate.x = actualPosX;
                            coordinate.y = horizonRelativePos * canvas.height;
                            mountainCoordinates.unshift(coordinate);
                            break;
                        }

                        if (angle > leftAngle + angleDiff) {
                            angle -= Math.random() / divider;
                        } else if (angle < leftAngle - angleDiff) {
                            angle += Math.random() / divider;
                        } else {
                            angle += Math.random() / divider - 0.5 / divider;
                        }

                        if (angle > Math.PI / 2) {
                            angle = Math.PI / 2;
                        }

                        if (angle < -Math.PI / 2) {
                            angle = -Math.PI / 2;
                        }

                        actualPosY = actualPosY - Math.tan(angle) * xInterval;

                        mountainCoordinates.unshift(coordinate);
                    }

                    //right slope
                    actualPosY = canvas.height * (horizonRelativePos - mountainRelativeHeight);
                    angle = 0;
                    for (var actualPosX = startingPosX; actualPosX < canvas.width + xInterval; actualPosX += xInterval) {
                        var coordinate = new Object();
                        if(actualPosY < horizonRelativePos * canvas.height) {
                            coordinate.x = actualPosX;
                            coordinate.y = actualPosY;
                        } else {
                            coordinate.x = actualPosX;
                            coordinate.y = horizonRelativePos * canvas.height;
                            mountainCoordinates.push(coordinate);
                            break;
                        }

                        if (angle > Math.PI / 2) {
                            angle = Math.PI / 2;
                        }

                        if (angle < -Math.PI / 2) {
                            angle = -Math.PI / 2;
                        }

                        if (angle > rightAngle + angleDiff) {
                            angle -= Math.random() / divider;
                        } else if (angle < rightAngle - angleDiff) {
                            angle += Math.random() / divider;
                        } else {
                            angle += Math.random() / divider - 0.5 / divider;
                        }

                        actualPosY = actualPosY - Math.tan(angle) * xInterval;
                        
                        mountainCoordinates.push(coordinate);
                    }

                    if (mountainCoordinates[0].x <= xInterval && mountainCoordinates[0].y < horizonRelativePos * canvas.height) {
                        var coordinate = new Object();
                        coordinate.x = 0;
                        coordinate.y = horizonRelativePos * canvas.height;
                        mountainCoordinates.unshift(coordinate);
                    }

                    if (mountainCoordinates[mountainCoordinates.length -1].x >= canvas.width - xInterval 
                        && mountainCoordinates[mountainCoordinates.length -1].y <horizonRelativePos * canvas.height) {
                        var coordinate = new Object();
                        coordinate.x = canvas.width;
                        coordinate.y = horizonRelativePos * canvas.height;
                        mountainCoordinates.push(coordinate);
                    }

                    drawMountain();
                    
                }

                function drawMountain(){
                    ctx.beginPath();
                    //
                    //ctx.globalCompositeOperation = "destination-out";
                    ctx.moveTo(mountainCoordinates[0].x, mountainCoordinates[0].y);
                    for (var i = 0; i < mountainCoordinates.length; i++) {
                        var coordinate = mountainCoordinates[i];
                        ctx.lineTo(coordinate.x, coordinate.y);
                    }
                    ctx.fill();
                    drawHorizon();
                }

                function drawHorizon() {
                    ctx.lineWidth = 1;
                    //ctx.beginPath();
                    //
                    //ctx.globalCompositeOperation = "destination-out";
                    ctx.moveTo(0, canvas.height * horizonRelativePos);
                    ctx.lineTo(canvas.width, canvas.height * horizonRelativePos);
                    ctx.stroke();
                }

                //grass drawing
                function initializeGrass() {
                    for(var i = 0; i < numColony; i++) {
                        var newColony = new Object();
                        newColony.posX = Math.random() * (canvas.width - 2 * horizontalMargin) + horizontalMargin;
                        newColony.posY = canvas.height * horizonRelativePos + Math.random() 
                            * (canvas.height * (1 - horizonRelativePos) - 2 * verticalMargin) + verticalMargin;
                        numLeaves = Math.random() * (maxLeaves - minLeaves) + minLeaves;
                        var newLeaves = [];
                        for(var j = 0; j < numLeaves; j++) {
                            var leaf = {
                                a: Math.random() * (maxA - minA) + minA,
                                b: Math.random() * (maxB - minB) + minB,
                                c: Math.random() * (maxC - minC) + minC,
                                width: Math.random() * (maxWidth - minWidth) + minWidth,
                                height: Math.random() * (maxHeight - minHeight) + minHeight,
                                numCtrPt: 20,
                                direction: Math.random() > 0.5? leafDirLeft : leafDirRight,
                                bend: Math.random() * (bendabilityMax - bendabilityMin) + bendabilityMin
                            };

                            function eq(a, b, x) {
                                return Math.sqrt(1 + a**(2*b*x) * b**2 * Math.log(a)**2);
                            }
                            //(-tanh^(-1)(sqrt(1 + a^(2 b x) b^2 log^2(a))) + sqrt(1 + a^(2 b x) b^2 log^2(a)))/(b log(a))
                            //var le = (eq(leaf.a, leaf.b, leaf.numCtrPt) - Math.atanh(eq(leaf.a, leaf.b, leaf.numCtrPt)%1)) / (leaf.b * Math.log(leaf.a));
                            //var ls = (eq(leaf.a, leaf.b, 0) - Math.atanh(eq(leaf.a, leaf.b, 0)%1)) / (leaf.b * Math.log(leaf.a));
                            //leaf.length = le-ls;
                            //console.log(leaf.length);
                            newLeaves.push(leaf);
                        }
                        newColony.leaves = newLeaves;
                        colonyArr.push(newColony);
                    }
                
                    drawColonies();
                }

                function drawGrass(context, colony) {
                    var posX = colony.posX;
                    var posY = colony.posY;
                    for(var i = 0; i < colony.leaves.length; i++) {
                        var thisLeaf = colony.leaves[i];
                        var a = thisLeaf.a;
                        var b = thisLeaf.b;
                        var c = thisLeaf.c;
                        var incX = posX;
                        var incY = posY;
                        var dir = 0;
                        context.lineWidth = thisLeaf.width;
                        //
                        //context.globalCompositeOperation = "destination-out";
                        context.beginPath();
                        context.moveTo(posX + c, posY);
                        for(var j = 0; j < thisLeaf.numCtrPt; j++) {
                            dir = Math.atan(10 * b / thisLeaf.numCtrPt * a ** (b * j * 10 / thisLeaf.numCtrPt) * Math.log(a) * thisLeaf.direction);
                            var leng = thisLeaf.height / thisLeaf.numCtrPt / Math.cos(dir);
                            const xx = Math.sin(dir) * leng;
                            const yy = thisLeaf.height / thisLeaf.numCtrPt;
                            const windSideWayForce = windX * yy - windY * xx;
                            dir += 300 * (j + 1) * (windStrength * windActual) * ((1 - width * 0.2) ** thisLeaf.bend) * windSideWayForce;

                            context.lineWidth = thisLeaf.width - j * (thisLeaf.width - 1) / (thisLeaf.numCtrPt);
                            
                            if(dir > Math.PI/2) dir = Math.PI/2;
                            else if(dir < -Math.PI/2) dir = -Math.PI/2;

                            incX += Math.sin(dir) * leng;
                            incY -= Math.cos(dir) * leng;

                            context.lineTo(incX + c, incY);
                            context.stroke();
                        }

                        
                    }
                }    

                function drawColonies() {
                    for(var i = 0; i < colonyArr.length; i++) {
                        drawGrass(ctx, colonyArr[i]);
                    }
                }
                
                initializeMountain();
                initializeGrass();

                function updateWind() {
                    if (Math.random() < gustProbability) {
                        windCycleGustTime = (Math.random() * 10 + 1) | 0;
                    }
                    if (windCycleGustTime > 0) {
                        windCycleGustTime --;
                        windCycleGust += windCycleGustTime/20
                    } else {
                        windCycleGust *= 0.99;
                    }
                    windCycle += windCycleGust;
                    currentWind = (Math.sin(windCycle/40) * 0.6 + 0.4) ** 2;
                    currentWind = currentWind < 0 ? 0 : currentWind;
                    windFollow += (currentWind - windActual) * windBendRectSpeed;
                    windFollow *= windBranchSpring ;
                    windActual += windFollow;

                    console.log(windActual);
                }

                requestAnimationFrame(update);

                function update() {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    updateWind();
                    drawColonies();
                    drawMountain();
                    requestAnimationFrame(update);
                }
            }




        </script>
        <!--<script src="aa.js"></script>-->
    </head>
    <body style="text-align: center; margin: 0px; position:fixed">
        <!--
        <div style="position:fixed">
            <input type="number" id="a" value="1.2">
            <input type="number" id="b" value="0">
            <input type="number" id="c" value="2">
            <input type="button" id="button" value="Button">
        </div>
        -->
        <canvas id="canvas" style="z-index: 2; position: absolute;"></canvas>
    </body>
</html>
